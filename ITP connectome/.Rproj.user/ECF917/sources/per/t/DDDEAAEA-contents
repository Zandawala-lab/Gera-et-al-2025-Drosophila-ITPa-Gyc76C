#----Figure_8 ------------------------------------------------------------------
#-------------------------------------------------------------------------------
# This is the code for Figure 13A-D (ITP input/output)

# all csv files were downloaded from codex on 07/27/2025 - updated from previous
# versions, especially synapses
# https://codex.flywire.ai/?dataset=fafb
#-------------------------------------------------------------------------------

# Load packages:----------------------------------------------------------------
library(tidyverse)
library(ggplot2)
#library(fafbseg)
#library(natverse)

# Setup:------------------------------------------------------------------------
options(scipen=999)

PATH_input = "./input/"
PATH_output = "./output/"

# check if folders exist, if not, make them
if(!dir.exists(file.path(PATH_input))){
  dir.create(file.path(PATH_input))
}
if(!dir.exists(file.path(PATH_output))){
  dir.create(file.path(PATH_output))
}

input_files = list.files(path = PATH_input, full.names = FALSE, recursive = FALSE)
# input_files_tmp = list.files(path = paste0(PATH_input,"tmp/"),
#                              full.names = FALSE, recursive = FALSE)
# input_files = c(input_files,input_files_tmp)
v = read_delim(paste0(PATH_input,"version.csv"),
               col_types  =  cols(version  =  col_character()),delim  =  ";")
v = v$version[1]

# set colors:-------------------------------------------------------------------

## Decide if keeping or adjusting
# m_NSC_unknown = "#BFD739"#bbff48
# l_NSC_unknown = "#009817"
# m_NSC_DILP = "#BD0023"
# m_NSC_DH44 = "#ffe200"
# m_NSC_DMS = "#FE7E00"
# l_NSC_CRZ = "#8100FF"
# l_NSC_ITP = "#838383"
# l_NSC_DH31 = "#00B4FF"
# SEZ_NSC_CAPA = "#003BBD"
# SEZ_NSC_Hugin = "#BD00B0"

# used for synapse location plotting
l_NSC_ITP = "#838383" 
LNv_5th = "#00FFFF"   #BD0023
LNd_ITP = "#ffe200"

syn_col <- c("l_NSC_ITP" = l_NSC_ITP, "5th_LNv" = LNv_5th, "LNd_ITP" = LNd_ITP)

# super class plotting
super_class_colors <- c("endocrine" = "#5f50a1", # other
                        "undefined" = "white",
                        "optic" = "black", # 999999
                        "descending" = "#c3905f",  
                        "visual_centrifugal" = "#f46d43",
                        "central" = "#3384b8", 
                        "visual_projection" = "#c8d684", 
                        "sensory" = "#b73545", 
                        "ascending" = "#a9d5a3")

# neurotransmitter_colors <- c("ACH" = "#B9529F", # magenta
#                              "GLUT" = "#51B848", #limegreen
#                              "GABA" = "orange", 
#                              "uncertain" = "black",
#                              "other" = "lightgrey")

# load data:--------------------------------------------------------------------
# if (!paste0("NSC_input_filtered_v",v,".csv")  %in%  input_files) {
#   reticulate::source_python("./scripts/Figure_3/Figure_3_preparation.py")
# }
# here we are not using reticulate and cave client, we downloaded the updated 
# synapse table from codex and will filter the ITP neurons that we need (next)
synapses = read_csv(paste0(PATH_input,"fafb_v783_princeton_synapse_table.csv"),
                          col_types = cols(pre_root_id_720575940 = col_character(),
                                           post_root_id_720575940 = col_character()))

# old version to test - no autapses
# synapse_coords = read_csv(paste0(PATH_input,"synapse_coordinates.csv"),
#                     col_types = cols(pre_root_id = col_character(),
#                                      post_root_id = col_character()))

# provided file with ITP ids identified from codex
ITP_ids = read_delim(paste0(PATH_input,"ITP_v",v,".csv"),
                 col_types = cols(ITP_id = col_character(),
                             ITP_short_id = col_character()),
                             delim = ",")

# Check for classification file
if (!paste0("classification_v", v, ".csv") %in% list.files(PATH_input)) {
  stop("please go to https://codex.flywire.ai/api/download and download the classification file for the current version and save it in './input'.")
}

classification <- read_delim(paste0(PATH_input, "classification_v", v, ".csv"),
                             delim = ",",
                             escape_double = FALSE,
                             col_types = cols(root_id = col_character(), flow = col_character()),
                             trim_ws = TRUE)
classification <- as.data.frame(classification)

# Neurotransmitter classification
if (!("neurotransmitters.csv") %in% list.files(PATH_input)) {
  stop("please go to https://codex.flywire.ai/api/download and download neurotransmitters file for the current version and save it in './input'.")
}

neurotransmitters <- read_delim(paste0(PATH_input, "neurotransmitters.csv"),
                             delim = ",",
                             escape_double = FALSE,
                             col_types = cols(root_id = col_character()),
                             trim_ws = TRUE)

cell_types <- read_delim(paste0(PATH_input, "consolidated_cell_types.csv"),
                         col_types = cols(root_id = col_character(),
                                          primary_type = col_character(),
                                          `additional_type(s)` = col_character()),
                         delim = ",")


# To test - probably not used
# DELETE LATER
# connections = read_csv(paste0(PATH_input,"connections_princeton_no_threshold.csv"),
#                     col_types = cols(pre_root_id = col_character(),
#                                      post_root_id = col_character()))
# 
# connections_filtered = read_csv(paste0(PATH_input,"connections_princeton.csv"),
#                        col_types = cols(pre_root_id = col_character(),
#                                         post_root_id = col_character()))



# Adjust naming in dfs ---------------------------------------------------------
synapses <- synapses %>%
  rename(pre_root_id = pre_root_id_720575940,
         post_root_id = post_root_id_720575940)

cell_types <- cell_types %>%
  rename(cell_type = primary_type,
         cell_type_additional = `additional_type(s)`)

# filter synapse table ---------------------------------------------------------
# filter out autapses
synapses_no_autapses <- synapses %>%
  filter(pre_root_id != post_root_id)

# ITP ids are pre, so find outputs
synapses_output_ITP <- synapses_no_autapses %>%
  semi_join(ITP_ids, by = c("pre_root_id" = "ITP_short_id"))

synapses_output_ITP <- synapses_output_ITP %>%
  mutate(
    pre_root_id = paste0("720575940", as.character(pre_root_id)),
    post_root_id  = paste0("720575940", as.character(post_root_id))
  )

# ITP ids are post, so find inputs
synapses_input_ITP <- synapses_no_autapses %>%
  semi_join(ITP_ids, by = c("post_root_id" = "ITP_short_id"))

synapses_input_ITP <- synapses_input_ITP %>%
  mutate(
    pre_root_id = paste0("720575940", as.character(pre_root_id)),
    post_root_id = paste0("720575940", as.character(post_root_id))
  )

# come back and remove

# # Join dfs and rename cols
# ITP_join <- ITP_ids
# colnames(ITP_join) <- c("name_post", "post_root_id", "post_short_id", "hemisphere_post")
# ITP_input_self_labeled <- left_join(synapse_input_self_check, ITP_join, by = "post_root_id")
# 
# # about equal distribution across the 3 groups
# ITP_input_self_grouped <- ITP_input_self_labeled %>%
#   group_by(name_post) %>%
#   summarise(names_count = n())




#-------------------------------------------------------------------------------
# Plot input synapses of ITP

# Open a new 3D plot
open3d()
# Set high resolution for the plot
par3d(windowRect = c(0, 0, 3840, 2160))  # Set to 4K resolution (3840x2160)

# Iterate over unique NSC names and plot synapses
for (i in rev(unique(ITP_ids$ITP_name))) {
  # Get the ids for the current ITP_name
  ids <- ITP_ids %>% filter(ITP_name == i) %>% pull(ITP_id)
  # Filter the synapses for the current ids
  synapses_filtered <- synapses_input_ITP %>% filter(post_root_id %in% ids)
  # Plot the pre-synaptic positions
  plot3d(synapses_filtered$post_x, synapses_filtered$post_y, synapses_filtered$post_z,
         col = syn_col[i], size = 0.5, type = "s", add = TRUE)
}

# Add the surface model
brainmesh <- readOBJ(paste0(PATH_output,"neurons_v783/NSC/brainmesh.obj"))

plot3d(brainmesh, add = TRUE, alpha = 0.1, col = "grey")
# Adjust the view
view3d(userMatrix = rotationMatrix(90 * pi / 90, 1, 0, 0), zoom = 0.5)  

# Export as html
p<-rglwidget(webgl=TRUE, width = 1920, height = 1080)
htmltools::save_html(p, paste0(PATH_output,"Figure_8/","Figure_8A_input_","v", v, ".html"))

# Export as png
png_filename <- paste0(PATH_output, "Figure_8/","Figure_8A_input_","v", v, ".png")
rgl.snapshot(png_filename)

# Close the 3D plot
close3d()

#-------------------------------------------------------------------------------
# Plot output synapses of ITP

# Open a new 3D plot
open3d()
# Set high resolution for the plot
par3d(windowRect = c(0, 0, 3840, 2160))  # Set to 4K resolution (3840x2160)

# Iterate over unique NSC names and plot synapses
for (i in rev(unique(ITP_ids$ITP_name))) {
  # Get the ids for the current ITP_name
  ids <- ITP_ids %>% filter(ITP_name == i) %>% pull(ITP_id)
  # Filter the synapses for the current ids
  synapses_filtered <- synapses_output_ITP %>% filter(pre_root_id %in% ids)
  # Plot the pre-synaptic positions
  plot3d(synapses_filtered$pre_x, synapses_filtered$pre_y, synapses_filtered$pre_z,
         col = syn_col[i], size = 0.5, type = "s", add = TRUE)
}

# Add the surface model
brainmesh <- readOBJ(paste0(PATH_output,"neurons_v783/NSC/brainmesh.obj"))

plot3d(brainmesh, add = TRUE, alpha = 0.1, col = "grey")
# Adjust the view
view3d(userMatrix = rotationMatrix(90 * pi / 90, 1, 0, 0), zoom = 0.5)  

# Export as html
p<-rglwidget(webgl=TRUE, width = 1920, height = 1080)
htmltools::save_html(p, paste0(PATH_output,"Figure_8/","Figure_8A_output_","v", v, ".html"))

# Export as png
png_filename <- paste0(PATH_output, "Figure_8/","Figure_8A_output_","v", v, ".png")
rgl.snapshot(png_filename)

# Close the 3D plot
close3d()


# This used synapses csv
#-------------------------------------------------------------------------------
# Analyze connectivity data for Figure panel D - *INPUTS*

# Summarize synapses data w/neuropil
ITP_input_sum <- synapses_input_ITP %>%
  group_by(pre_root_id, post_root_id, neuropil) %>%
  summarise(n_synapses = n())

# Summarize w/o neuropil
ITP_input_total_sum <- synapses_input_ITP %>%
  group_by(pre_root_id, post_root_id) %>%
  summarise(total_synapses = n())

# Join these tables
ITP_input_sum <- ITP_input_sum %>%
  left_join(ITP_input_total_sum, by = c("pre_root_id", "post_root_id"))

# Make a large classification table with neurotransmitters and other annotations
classification <- left_join(classification, neurotransmitters, by = "root_id")
# Reclassify neurotransmitters based on stringent cutoff
classification$nt_type_stringent <- classification$nt_type
classification <- classification %>%
  mutate(nt_type_stringent = ifelse(nt_type_score <= 0.62, "uncertain", nt_type_stringent))

classification <- left_join(classification, cell_types, by = "root_id")
classification <- classification %>%
  relocate(cell_type, .after = sub_class) %>%
  relocate(cell_type_additional, .after = cell_type)

# Join data for further analysis
classification_join <- classification
colnames(classification_join) <- c("pre_root_id", colnames(classification)[-1])



# threshold 5 synapses -----
ITP_input <- left_join(ITP_input_sum[ITP_input_sum$total_synapses >= 5, ], classification_join, by = "pre_root_id")
# unique(ITP_input$pre_root_id) # 106 and matches codex. autapses are filtered out in both


# Convert NA values to a detectable value and then mutate
ITP_input$nt_type_score[is.na(ITP_input$nt_type_score)] <- -1
ITP_input <- ITP_input %>%
  mutate(nt_type_stringent = ifelse(nt_type_score == -1, "uncertain", nt_type_stringent))

ITP_input$nt_type_stringent_corr <- ITP_input$nt_type_stringent
ITP_input <- ITP_input %>%
  mutate(nt_type_stringent_corr = case_when(
    nt_type_stringent_corr %in% c("GABA", "GLUT", "ACH", "uncertain") ~ nt_type_stringent_corr,
    TRUE ~ "other" ))

# Join dfs and rename cols - get info for ITP to ITP connections
ITP_join <- ITP_ids
colnames(ITP_join) <- c("name_post", "post_root_id", "post_short_id", "hemisphere_post")
ITP_input <- left_join(ITP_input, ITP_join, by = "post_root_id")
colnames(ITP_join) <- c("name_pre", "pre_root_id", "pre_short_id", "hemisphere_pre")
ITP_input <- left_join(ITP_input, ITP_join, by = "pre_root_id")


# Figure Panel B - Inputs

ITP_input_super_class <- ITP_input %>%
  group_by(name_post, super_class) %>%
  summarise(n_synapses_total = sum(total_synapses, na.rm = TRUE),
            n_pre_partners_total = length(unique(pre_root_id)))
# Save this data in temp
# write.csv(ITP_input_super_class, paste0(PATH_output, "ITP_input_classification_thresh5_v", v, ".csv"))

# ------------------------------------------------------------------------------
# Figure Panel C - Input Proportions

# Summarize data by ITP types
ITP_input_total <- ITP_input %>%4
  group_by(name_post) %>%
  summarise(n_synapses_total = sum(total_synapses, na.rm = TRUE),
            n_pre_partners_total = length(unique(pre_root_id)))

# Summarize groups by ITP types and super_class
ITP_input_sum_grouped <- ITP_input %>%
  group_by(super_class, name_post) %>%
  summarise(n_synapses_sum = sum(total_synapses, na.rm = TRUE),
            avrg_synapses = mean(total_synapses, na.rm = TRUE),
            n_pre_partners = length(unique(pre_root_id)),
            n_post_partners = length(unique(post_root_id)))

# Join summarized tables for calcs
ITP_input_sum_grouped <- left_join(ITP_input_sum_grouped, ITP_input_total, by = "name_post")
ITP_input_sum_grouped$perc_of_input <- ITP_input_sum_grouped$n_synapses_sum / ITP_input_sum_grouped$n_synapses_total

ITP_input_sum_grouped$name_post <- factor(ITP_input_sum_grouped$name_post,
                                          levels = rev(c("LNd_ITP", "5th_LNV", "l_NSC_ITP")))

ITP_input_sum_grouped$fill <- paste(ITP_input_sum_grouped$super_class, sep = "_")

ITP_input_sum_grouped <- ITP_input_sum_grouped %>%
  group_by(name_post, fill) %>%
  summarise(perc_of_input = sum(perc_of_input))

ITP_input_sum_grouped$fill_corr <- factor(ITP_input_sum_grouped$fill,
                                          levels = rev(c("endocrine",
                                                         "undefined",
                                                         "optic",
                                                         "descending",
                                                         "visual_centrifugal",
                                                         "central",
                                                         "visual_projection",
                                                         "sensory",
                                                         "ascending")))

# Diagnostic print
print(ITP_input_sum_grouped)

# ------------------------------------------------------------------------------
# Plot input synapse proportions

p <- ggplot(ITP_input_sum_grouped, aes(x = name_post, y = perc_of_input, fill = fill)) +
  geom_bar(stat = "identity", color = "black", linewidth = 0.1) +
  facet_grid(scales = "free_x", space = "free_x") +
  scale_fill_manual(values = super_class_colors,
                    guide = guide_legend(nrow = 1)) +
  ylab("Proportion of input synapses") +
  xlab("") +
  theme(panel.background = element_rect(fill = NA, color = NA),
        strip.background = element_rect(colour = NA, fill = NA),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.margin = unit(c(0, 0, 0, 0), "mm"),
        panel.border = element_rect(colour = "black", fill = NA, linewidth = 0.5),
        legend.title = element_blank(),
        legend.position = "bottom",
        text = element_text(size = 10, colour = "black"),
        axis.text.x = element_text(angle = 270, vjust = 0.5, hjust = 0),
        axis.text.y = element_text(angle = 0),
        axis.ticks.x = element_blank())
print(p)

ggsave(paste0(PATH_output, "Figure_8/Figure_8_PropInputSynapses_v", v, ".pdf"), plot = p, width = 12, height = 10, units = "cm")




#-------------------------------------------------------------------------------
# Analyze connectivity data for Figure panel D - *OUTPUT*

# Summarize synapses data
ITP_output_sum <- synapses_output_ITP %>%
  group_by(pre_root_id, post_root_id, neuropil) %>%
  summarise(n_synapses = n())

ITP_output_total_sum <- synapses_output_ITP %>%
  group_by(pre_root_id, post_root_id) %>%
  summarise(total_synapses = n())

# now join these tables
ITP_output_sum <- ITP_output_sum %>%
  left_join(ITP_output_total_sum, by = c("pre_root_id", "post_root_id"))

# Do not rerun if run above
# classification <- left_join(classification, neurotransmitters, by = "root_id")
# # Reclassify neurotransmitters based on stringent cutoff
# classification$nt_type_stringent <- classification$nt_type
# classification <- classification %>%
#   mutate(nt_type_stringent = ifelse(nt_type_score <= 0.62, "uncertain", nt_type_stringent))
# classification <- left_join(classification, cell_types, by = "root_id")
# classification <- classification %>%
#   relocate(cell_type, .after = sub_class) %>%
#   relocate(cell_type_additional, .after = cell_type)

# Join data for further analysis
classification_join <- classification
colnames(classification_join) <- c("post_root_id", colnames(classification)[-1])

# threshold 5 synapses -----
ITP_output <- left_join(ITP_output_sum[ITP_output_sum$total_synapses >= 5, ], classification_join, by = "post_root_id")
# unique(ITP_output$post_root_id) # 301 and matches codex. autapses are filtered out in both


# Convert NA values to a detectable value and then mutate
ITP_output$nt_type_score[is.na(ITP_output$nt_type_score)] <- -1
ITP_output <- ITP_output %>%
  mutate(nt_type_stringent = ifelse(nt_type_score == -1, "uncertain", nt_type_stringent))

ITP_output$nt_type_stringent_corr <- ITP_output$nt_type_stringent
ITP_output <- ITP_output %>%
  mutate(nt_type_stringent_corr = case_when(
    nt_type_stringent_corr %in% c("GABA", "GLUT", "ACH", "uncertain") ~ nt_type_stringent_corr,
    TRUE ~ "other" ))

# Join dfs and rename cols - get info for ITP to ITP connections
ITP_join <- ITP_ids
colnames(ITP_join) <- c("name_post", "post_root_id", "post_short_id", "hemisphere_post")
ITP_output <- left_join(ITP_output, ITP_join, by = "post_root_id")
colnames(ITP_join) <- c("name_pre", "pre_root_id", "pre_short_id", "hemisphere_pre")
ITP_output <- left_join(ITP_output, ITP_join, by = "pre_root_id")

# Figure Panel B - Outputs
ITP_output_super_class <- ITP_output %>%
  group_by(super_class, name_pre) %>%
  summarise(n_synapses_total = sum(total_synapses, na.rm = TRUE),
    n_pre_partners_total = length(unique(pre_root_id)),
    n_post_partners_total = length(unique(post_root_id)))
# Save this data in temp
# write.csv(ITP_output_super_class, paste0(PATH_output, "ITP_output_classification_thresh5_v", v, ".csv"))


# ------------------------------------------------------------------------------
# Analysis for Figure 8C - Inputs

col_to_keep =c("pre_root_id","cell_type","cell_type_additional", "class","name_pre",
               "name_post","hemisphere_post","post_root_id","n_synapses", "total_synapses",
               "nt_type_score", "nt_type", "nt_type_stringent", "nt_type_stringent_corr")

for (itp_type in unique(ITP_input$name_post)) {
  # current ITP type
  ITP_input_subset <- ITP_input[ITP_input$name_post == itp_type, ]

for (i in unique(ITP_input_subset$super_class)) {
  if (!is.na(i)) {
    # Filter the data for the current ITP ids
    ITP_subset_superclass <- unique(ITP_input_subset[ITP_input_subset$super_class == i,][col_to_keep])
    # Name and save file
    filename <- paste("Figure_8/ITP_all_inputs/Figure_8C_ITP_all_input_filtered_5_syn_threshold_",
                      itp_type, "_", i, sep = "")
    write.csv(ITP_subset_superclass,paste0(PATH_output,
                                           filename,"_v", v,".csv"))
    
    # Assign values to cell_type from class or pre_root_id if they are NA
    ITP_subset_superclass$cell_type = ifelse(
      is.na(ITP_subset_superclass$cell_type),
      ifelse(
        is.na(ITP_subset_superclass$class),
        ITP_subset_superclass$pre_root_id,
        ITP_subset_superclass$class
        ),
        ITP_subset_superclass$cell_type
      )

    # Top 10 cell_types by # of synapses
    top_tmp = ITP_subset_superclass %>%
      group_by(cell_type) %>%
      summarize(total_syn = sum(n_synapses))
    
    top10_tmp = top_tmp[order(-top_tmp$total_syn),]$cell_type[1:10]
    ITP_subset_superclass_top = ITP_subset_superclass[ITP_subset_superclass$cell_type %in% top10_tmp,]
    
    # Create a data frame with cell_type and their respective order
    order_df = data.frame(cell_type = top10_tmp, order = 1:10)
    # Merge the order information into ITP_subset_superclass_top
    ITP_subset_superclass_top = merge(ITP_subset_superclass_top, order_df, by = "cell_type")
    write.csv(ITP_subset_superclass_top,paste0(PATH_output,
              "Figure_8/Top_inputs_ITP/Figure_8C_input_to_",itp_type, "_from_", i, "_top_10_",v,".csv"))
  }
 }
}


# ------------------------------------------------------------------------------
# Analysis for Figure 8C - Outputs

col_to_keep =c("pre_root_id","cell_type","cell_type_additional", "class","name_pre",
               "name_post","hemisphere_post","post_root_id","n_synapses", "total_synapses",
               "nt_type_score", "nt_type", "nt_type_stringent", "nt_type_stringent_corr")

for (itp_type in unique(ITP_output$name_pre)) {
  # current ITP type
  ITP_output_subset <- ITP_output[ITP_output$name_pre == itp_type, ]
  
  for (i in unique(ITP_output_subset$super_class)) {
    if (!is.na(i)) {
      # Filter the data for the current ITP ids
      ITP_subset_superclass <- unique(ITP_output_subset[ITP_output_subset$super_class == i,][col_to_keep])
      # Name and save file
      filename <- paste("Figure_8/ITP_all_outputs/Figure_8C_ITP_all_output_filtered_5_syn_threshold_",
                        itp_type, "_", i, sep = "")
      write.csv(ITP_subset_superclass,paste0(PATH_output,
                                             filename,"_v", v,".csv"))
      
      # Assign values to cell_type from class or post_root_id if they are NA
      ITP_subset_superclass$cell_type = ifelse(
        is.na(ITP_subset_superclass$cell_type),
        ifelse(
          is.na(ITP_subset_superclass$class),
          ITP_subset_superclass$post_root_id,
          ITP_subset_superclass$class
        ),
        ITP_subset_superclass$cell_type
      )
      
      # Top 10 cell_types by # of synapses
      top_tmp = ITP_subset_superclass %>%
        group_by(cell_type) %>%
        summarize(total_syn = sum(n_synapses))
      
      top10_tmp = top_tmp[order(-top_tmp$total_syn),]$cell_type[1:10]
      ITP_subset_superclass_top = ITP_subset_superclass[ITP_subset_superclass$cell_type %in% top10_tmp,]
      
      # Create a data frame with cell_type and their respective order
      order_df = data.frame(cell_type = top10_tmp, order = 1:10)
      # Merge the order information into ITP_subset_superclass_top
      ITP_subset_superclass_top = merge(ITP_subset_superclass_top, order_df, by = "cell_type")
      write.csv(ITP_subset_superclass_top,paste0(PATH_output,
                                                 "Figure_8/Top_outputs_ITP/Figure_8C_output_from_",itp_type, "_to_", i, "_top_10_",v,".csv"))
    }
  }
}

## Exploratory -----------------------------------------------------------------
# Find endocrine IDs that are inputs/outputs
# ------------------------------------------------------------------------------
ITP_input_endocrine <- ITP_input %>%
  filter(super_class == "endocrine")
# input to l_NSC_ITP - two unique pre IDs (one is DH31 and one is itself): https://ngl.flywire.ai/?json_url=https://globalv1.flywire-daf.com/nglstate/4975833063096320

ITP_output_endocrine <- ITP_output %>%
  filter(super_class == "endocrine")
paste0(unique(ITP_output_endocrine$post_root_id), collapse = ",") # total 43 rows, 12 unique pre_ids
# ITP outputs to endocrine- 12 unique post ids (includes DH31, CRZ, NSC unknown): https://ngl.flywire.ai/?json_url=https://globalv1.flywire-daf.com/nglstate/6627004769107968


# input to LNd_ITP
LNd_ITP_input <- ITP_input %>%
  filter(name_post == "LNd_ITP")
paste0(unique(LNd_ITP_input$pre_root_id), collapse = ",") # total 303 rows, 96 unique pre_ids
# input to LNd_ITP: https://ngl.flywire.ai/?json_url=https://globalv1.flywire-daf.com/nglstate/5195130670678016




# # ------------------------------------------------------------------------------
# ## CODE CHECKS - RERUN THIS SECTION, BUT USE CONNECTIVITY (Unfiltered) TABLE FROM CODEX DOWNLOAD
# # ***************
# synapses_input_connections <- connections %>%
#   semi_join(ITP_ids, by = c("post_root_id" = "ITP_id"))
# 
# synapses_input_connections_thresh5 <- synapses_input_connections[synapses_input_connections$syn_count >= 5, ]
# 
# #unique(filtered_synapses_input_connections_thresh5$pre_root_id) # 90
# 
# test2 <- connections_filtered %>%
#   semi_join(ITP_ids, by = c("post_root_id" = "ITP_id"))
# 
# filtered_test <- test2[test2$syn_count >= 5, ]
# 
# test_overall <- connections_filtered[connections_filtered$syn_count < 5, ]
# 
# 
# 
# # synapses
# # old - none
# synapse_coords_test <- synapse_coords %>%
#   filter(pre_root_id == post_root_id)
# 
# # new
# # many of these
# synapse_self_test <- synapses %>%
#   filter(pre_root_id == post_root_id)
# 
# # connections
# # new
# connections_filtered_self_test <- connections_filtered %>%
#   filter(pre_root_id == post_root_id)
# connections_unfiltered_self_test <- connections %>%
#   filter(pre_root_id == post_root_id)

# # Code checks ------------------------------------------------------------------
# # checking bc numbers above don't seem to match codex
# 
# # filter out where ITP appears as pre and post
# filtered_df <- ITP_output %>%
#   filter(!is.na(name_post))
# 
# # output check
# self_synapse_output <- filtered_df %>%
#   filter(pre_root_id == post_root_id)
# 
# # input check
# self_synapse_input <- synapses_input %>%
#   filter(pre_root_id == post_root_id)
# 
# # self connections
# self_synapse_test <- synapses %>%
#   filter(pre_root_id == post_root_id)
# 
# 
# # checking overall dataset
# 
# synapse_counts_overall <- synapses %>%
#   group_by(pre_root_id, post_root_id) %>%
#   summarise(n_synapses = n())
# 
# synapses_overall_thresh5 <- synapse_counts_overall[synapse_counts_overall$n_synapses >= 5, ]
# 
# 
# # self connections
# self_synapse_count_overall <- synapse_counts_overall %>%
#   filter(pre_root_id == post_root_id)
# 
# # ------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
## ** Checking, likely not used **
#-------------------------------------------------------------------------------
# threshold 3 synapses -----
ITP_input_lowthresh <- left_join(ITP_input_sum[ITP_input_sum$n_synapses >= 3, ], classification_join, by = "pre_root_id")

# Convert NA values to a detectable value and then mutate
ITP_input_lowthresh$nt_type_score[is.na(ITP_input_lowthresh$nt_type_score)] <- -1
ITP_input_lowthresh <- ITP_input_lowthresh %>%
  mutate(nt_type_stringent = ifelse(nt_type_score == -1, "uncertain", nt_type_stringent))

ITP_input_lowthresh$nt_type_stringent_corr <- ITP_input_lowthresh$nt_type_stringent
ITP_input_lowthresh <- ITP_input_lowthresh %>%
  mutate(nt_type_stringent_corr = case_when(
    nt_type_stringent_corr %in% c("GABA", "GLUT", "ACH", "uncertain") ~ nt_type_stringent_corr,
    TRUE ~ "other" ))

# Join dfs and rename cols - this is on all data (not filtered based on synapse threshold)
ITP_join <- ITP_ids
ITP_join$NSC_id_old <- NULL
colnames(ITP_join) <- c("name_post", "post_root_id", "post_short_id", "hemisphere_post")
ITP_input_lowthresh <- left_join(ITP_input_lowthresh, ITP_join, by = "post_root_id")
colnames(ITP_join) <- c("name_pre", "pre_root_id", "pre_short_id", "hemisphere_pre")
ITP_input_lowthresh <- left_join(ITP_input_lowthresh, ITP_join, by = "pre_root_id")

# Summarize NSC input data
ITP_input_total_lowthresh <- ITP_input_lowthresh %>%
  group_by(name_post) %>%
  summarise(n_synapses_total = sum(n_synapses, na.rm = TRUE),
            n_pre_partners_total = length(unique(pre_root_id)))
ITP_input_lowthresh$post_root_id_name <- paste(ITP_input_lowthresh$post_root_id, ITP_input_lowthresh$name_post, sep = "_")


ITP_input_lowthresh_super_class <- ITP_input_lowthresh %>%
  group_by(name_post, super_class) %>%
  summarise(n_synapses_total = sum(n_synapses, na.rm = TRUE),
            n_pre_partners_total = length(unique(pre_root_id)))
# Save this data in temp
# write.csv(ITP_input_lowthresh_super_class, paste0(PATH_output, "ITP_input_classification_thresh3_v", v, ".csv"))





# ------------------------------------------------------------------------------
# Extra code for ref:
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# Analysis for Figure 3_S2 
# S2_B

# Summarize NSC input data
NSC_input_subtype <- NSC_input %>%
  group_by(name_post) %>%
  summarise(n_synapses_total = sum(n_synapses, na.rm = TRUE),
            n_pre_partners_total = length(unique(pre_pt_root_id)),
            n_post_partners_total = length(unique(post_pt_root_id)))

write.csv(NSC_input_subtype, paste0(PATH_output, "Figure_3_S2/Figure_3_S2B_input_NSC_subtype_v", v, ".csv"))


#-------------------------------------------------------------------------------
# Figure_3_S2A

for (i in unique(NSC$NSC_name)) {
  # Get the NSC_ids for the current NSC_name
  NSC_ids <- NSC %>% filter(NSC_name == i) %>% pull(NSC_id)
  # Filter the data for the current NSC_ids
  NSC_subset <- NSC_input %>% filter(post_pt_root_id %in% NSC_ids)
  # save the file with correct name
  write.csv(NSC_subset, paste0(PATH_output, "Figure_3_S2/Figure_3_S2A_v",v,"_", i, ".csv"))
  
  # Aggregate the data to get the sum of n_synapses for each pre_pt_root_id
  NSC_aggregated <- NSC_subset %>%
    group_by(pre_pt_root_id, super_class) %>%
    summarize(n_synapses = sum(n_synapses), .groups = 'drop')
  
  # Select top 20 pre_pt_root_id based on n_synapses
  top20_subset <- NSC_aggregated %>%
    group_by(pre_pt_root_id) %>%
    summarize(n_synapses = sum(n_synapses)) %>%
    top_n(20, n_synapses)
  
  NSC_subset_top20 <- NSC_aggregated %>%
    filter(pre_pt_root_id %in% top20_subset$pre_pt_root_id)
  
  b <- ggplot(NSC_subset_top20, aes(x = fct_reorder(pre_pt_root_id, desc(n_synapses)), y = n_synapses, fill = super_class)) +
    geom_col() +
    labs(x = "", y = "", title = i) +
    scale_fill_manual(values = super_class_colors, na.value = "grey") +
    theme_classic() +
    theme(axis.text.x = element_text(size = 8, angle = 90, hjust = 1, color="black"),
          axis.text.y = element_text(size = 8, color="black"),
          axis.line = element_line(color = "black"),
          plot.title = element_text(size = 11, hjust = 0.5, color="black"),
          legend.title = element_blank(),
          text = element_text(size = 12, color="black")) +
          scale_y_continuous(breaks = waiver(), n.breaks = 5, expand = c(0,0))
  

  filename <- paste("Figure_3_S2A_top20_individual_inputs_",i, ".pdf", sep = "")
  ggsave(filename, plot = b, path = paste0(PATH_output,"Figure_3_S2/"), width = 6, height = 3, dpi = 300)  
}

#-------------------------------------------------------------------------------
# Analysis for Figure 3_S3 - inputs by neurotransmitters - S3_A

# top individual inputs to NSC subtypes by neurotransmitter
for (i in unique(NSC$NSC_name)) {
  # Get the NSC_ids for the current NSC_name
  NSC_ids <- NSC %>% filter(NSC_name == i) %>% pull(NSC_id)
  # Filter the data for the current NSC_ids
  NSC_subset <- NSC_input %>% filter(post_pt_root_id %in% NSC_ids)

  # Aggregate the data to get the sum of n_synapses for each pre_pt_root_id
  NSC_aggregated <- NSC_subset %>%
    group_by(pre_pt_root_id, nt_type_stringent_corr) %>%
    summarize(n_synapses = sum(n_synapses), .groups = 'drop')
  
  # Select top 20 pre_pt_root_id based on n_synapses
  top20_subset <- NSC_aggregated %>%
    group_by(pre_pt_root_id) %>%
    summarize(n_synapses = sum(n_synapses)) %>%
    top_n(20, n_synapses)
  
  NSC_subset_top20 <- NSC_aggregated %>%
    filter(pre_pt_root_id %in% top20_subset$pre_pt_root_id)
  
  b <- ggplot(NSC_subset_top20, aes(x = fct_reorder(pre_pt_root_id, desc(n_synapses)), y = n_synapses, fill = nt_type_stringent_corr)) +
    geom_col() +
    labs(x = "", y = "", title = i) +
    scale_fill_manual(values = neurotransmitter_colors) +
    theme_classic() +
    theme(axis.text.x = element_text(size = 8, angle = 90, hjust = 1, color="black"),
          axis.text.y = element_text(size = 8, color="black"),
          axis.line = element_line(color = "black"),
          plot.title = element_text(size = 11, hjust = 0.5, color="black"),
          legend.title = element_blank(),
          text = element_text(size = 12, color="black")) +
    scale_y_continuous(breaks = waiver(), n.breaks = 5, expand = c(0,0))
  
  filename <- paste("Figure_3_S3A_top20_individual_inputs_NT_",i, ".pdf", sep = "")
  ggsave(filename, plot = b, path = paste0(PATH_output,"Figure_3_S3/"), width = 6, height = 3, dpi = 300)  
}

#-------------------------------------------------------------------------------
# summary of inputs to NSC by neurotransmitter type- S3_B

NSC_input_sum_NT <- NSC_input %>%
  group_by(nt_type_stringent_corr, name_post) %>%
  summarise(n_synapses_sum = sum(n_synapses, na.rm = TRUE),
            avrg_synapses = mean(n_synapses, na.rm = TRUE),
            n_pre_partners = length(unique(pre_pt_root_id)),
            n_post_partners = length(unique(post_pt_root_id)))

NSC_input_sum_NT <- left_join(NSC_input_sum_NT, NSC_input_total, by = "name_post")
NSC_input_sum_NT$perc_of_input <- NSC_input_sum_NT$n_synapses_sum / NSC_input_sum_NT$n_synapses_total

NSC_input_sum_NT$name_post <- factor(NSC_input_sum_NT$name_post,
                                     levels = rev(c("m_NSC_unknown", "l_NSC_unknown", "m_NSC_DILP",
                                                    "m_NSC_DH44", "m_NSC_DMS", "l_NSC_CRZ",
                                                    "l_NSC_ITP", "l_NSC_DH31", "SEZ_NSC_CAPA",
                                                    "SEZ_NSC_Hugin")))

NSC_input_sum_NT$fill <- paste(NSC_input_sum_NT$nt_type_stringent_corr, sep = "_")

NSC_input_sum_NT <- NSC_input_sum_NT %>%
  group_by(name_post, fill) %>%
  summarise(perc_of_input = sum(perc_of_input))

NSC_input_sum_NT$fill <- factor(NSC_input_sum_NT$fill,
                                     levels = rev(c("uncertain",
                                                    "other",
                                                    "GABA",
                                                    "GLUT",
                                                    "ACH")))

# Diagnostic print
print(NSC_input_sum_NT)

# Plot bar chart
custom_labels <- c("SEZ-NSC^Hugin","SEZ-NSC^CAPA","l-NSC^DH31","l-NSC^CRZ","m-NSC^DMS","m-NSC^DH44","m-NSC^DILP","l-NSC^unknown","m-NSC^unknown")

q <- ggplot(NSC_input_sum_NT, aes(x = name_post, y = perc_of_input, fill = fill)) +
  geom_bar(stat = "identity", color = "black", linewidth = 0.1) +
  facet_grid(scales = "free_x", space = "free_x") +
  scale_fill_manual(values = neurotransmitter_colors,
                    guide = guide_legend(nrow = 1)) +
  scale_x_discrete(labels = parse(text = custom_labels)) +
  ylab("Proportion of input synapses") +
  xlab("") +
  theme(panel.background = element_rect(fill = NA, color = NA),
        strip.background = element_rect(colour = NA, fill = NA),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.margin = unit(c(0, 0, 0, 0), "mm"),
        panel.border = element_rect(colour = "black", fill = NA, linewidth = 0.5),
        legend.title = element_blank(),
        legend.position = "bottom",
        text = element_text(size = 10, colour = "black"),
        axis.text.x = element_text(angle = 270, vjust = 0.5, hjust = 0),
        axis.text.y = element_text(angle = 0),
        axis.ticks.x = element_blank())

print(q)
ggsave(paste0(PATH_output, "Figure_3_S3/Figure_3_S3B_v", v, ".pdf"), plot = q, width = 12, height = 10, units = "cm")
